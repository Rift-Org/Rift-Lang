/////////////////////////////////////////////////////////////
///                                                       ///
///     ██████╗ ██╗███████╗████████╗                      ///
///     ██╔══██╗██║██╔════╝╚══██╔══╝                      ///
///     ██████╔╝██║█████╗     ██║                         ///
///     ██╔══██╗██║██╔══╝     ██║                         ///
///     ██║  ██║██║██║        ██║                         ///
///     ╚═╝  ╚═╝╚═╝╚═╝        ╚═╝                         ///
///     * RIFT CORE - The official compiler for Rift.     ///
///     * Copyright (c) 2024, Rift-Org                    ///
///     * License terms may be found in the LICENSE file. ///
///                                                       ///
/////////////////////////////////////////////////////////////


#pragma once

#include <memory>
#include <vector>
#include <exception>
#include <scanner/tokens.hh>
#include <reader/reader.hh>
#include <ast/grmr.hh>
#include <ast/expr.hh>
#include <ast/stmt.hh>
#include <ast/decl.hh>
#include <ast/prgm.hh>

using namespace rift::scanner;
using namespace rift::reader;

namespace rift
{
    namespace ast
    {
        /// @class Parser
        /// @brief The parser class is responsible for parsing the tokens generated by the scanner.
        class Parser : public Reader<Token>
        {
            public:
                Parser(std::shared_ptr<std::vector<Token>> &tokens) : Reader<Token>(tokens), tokens(tokens)  {};
                ~Parser() = default;

                /// @brief Parses the tokens and returns an expression
                std::unique_ptr<Program<Tokens>> parse();
            protected:
                std::shared_ptr<std::vector<Token>> tokens;
                std::exception exception;

            private:
                #pragma mark - Grammar Evaluators
                
                /// @note rules in order of precedence <Expr>

                /// @example 1 + 2 * 3
                std::unique_ptr<Expr<Token>> expression();
                /// @example 1==1 ? print("hi") : print("else")
                std::unique_ptr<Expr<Token>> ternary();
                /// @example identifier = 1 + 3
                std::unique_ptr<Expr<Token>> assignment();
                /// @example 1 == 1, 1 != 2
                std::unique_ptr<Expr<Token>> equality();
                /// @example 1 > 2, 1 <= 2
                std::unique_ptr<Expr<Token>> comparison();
                /// @example 1 + 2, 1 - 2
                std::unique_ptr<Expr<Token>> term();
                /// @example 1 * 2, 1 / 2
                std::unique_ptr<Expr<Token>> factor();
                /// @example -1, !1
                std::unique_ptr<Expr<Token>> unary();
                /// @example method();
                std::unique_ptr<Expr<Token>> call();
                /// @example var test;
                std::unique_ptr<Expr<Token>> var_expr();
                /// @example 1, "string", true, false, nil
                std::unique_ptr<Expr<Token>> primary();

                /// @note rules in order of precedence <Stmt>

                /// @example function();
                std::unique_ptr<Stmt<void>> statement_expression();
                /// @example print(1 + 2);
                std::unique_ptr<Stmt<void>> statement_print();
                /// @example if (1+2) print(3);
                std::unique_ptr<Stmt<void>> statement_if();
                /// @example return 1;
                std::unique_ptr<Stmt<void>> statement_return();
                /// @example { var x = 1; }
                std::unique_ptr<Stmt<void>> statement_block();
                /// @example while(true) print("hi");
                std::unique_ptr<Stmt<void>> statement_for();

            
                /// @note rules in order of precedence <Decl>
                /// @example var x = 1;
                std::unique_ptr<Decl<Token>> declaration_statement();
                /// @example mut x = 1; mut! x = 5;
                std::unique_ptr<Decl<Token>> declaration_variable(bool mut);
                /// @example func test() {}
                std::unique_ptr<Decl<Token>> declaration_func();

                /// @brief returns any statements that might be executed 
                std::unique_ptr<Stmt<void>> ret_stmt();
                /// @brief returns any declarations that might be executed
                Program<Tokens>::vec_t ret_decl();


                /// @example func test() {}  or member.method()
                std::unique_ptr<DeclFunc<Token>::Func> function(); 
                /// @example 1, 2, 3
                Tokens params();
                /// @example 1+1, "str", a
                Call<Token>::Exprs args(Tokens params);
                /// @note program
                std::unique_ptr<Program<Tokens>> program();
                
                /// @brief Syncronizes the parser to avoid error-cascading
                void synchronize();
        };

        class ParserException : public ReaderException
        {
            public:
                ParserException(const std::string &message) : message(message) {}
                ~ParserException() = default;

                const char *what() const noexcept override { return message.c_str(); }

            private:
                std::string message;
        };
    }
}